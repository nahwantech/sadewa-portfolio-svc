package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"log"
	"sadewa-portfolio-svc/config"
	"sadewa-portfolio-svc/graph/model"
	"sadewa-portfolio-svc/graphqlutils"
	"time"
)

// CreateExperience is the resolver for the createExperience field.
func (r *mutationResolver) CreateExperience(ctx context.Context, input model.ExperienceInput) (*model.Experience, error) {
	panic(fmt.Errorf("not implemented: CreateExperience - createExperience"))
}

// UpdateExperience is the resolver for the updateExperience field.
func (r *mutationResolver) UpdateExperience(ctx context.Context, id string, input model.ExperienceInput) (*model.Experience, error) {
	panic(fmt.Errorf("not implemented: UpdateExperience - updateExperience"))
}

// DeleteExperience is the resolver for the deleteExperience field.
func (r *mutationResolver) DeleteExperience(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteExperience - deleteExperience"))
}

// Experience is the resolver for the experience field.
func (r *queryResolver) Experience(ctx context.Context, id string) (*model.Experience, error) {
	// print log
	graphqlutils.RequestLogger(ctx, "Query Experience by id")

	var p model.Experience
	var jobStartDate, jobFinishDate, createdAt, updatedAt *time.Time
	err := config.DB.QueryRow(ctx, `
		SELECT id, job_title, job_start_date, job_finish_date, job_description, created_at, created_by, updated_at, updated_by, is_active
		FROM mst_experience
		WHERE id=$1
	`, id).Scan(
		&p.ID, &p.JobTitle, &jobStartDate, &jobFinishDate, &p.JobDescription,
		&createdAt, &p.CreatedBy, &updatedAt, &p.UpdatedBy, &p.IsActive,
	)

	// ✅ Convert time.Time to model.Time
	if ts := model.TimeFromPtr(createdAt); ts != nil {
		p.CreatedAt = time.Time(*ts)
	}

	if ts := model.TimeFromPtr(jobStartDate); ts != nil {
		p.JobStartDate = time.Time(*ts)
	}

	if ts := model.TimeFromPtr(jobFinishDate); ts != nil {
		p.JobFinishDate = time.Time(*ts)
	}

	if err != nil {
		log.Println("Error fetching experience: ", err)
		return nil, err
	}

	graphqlutils.ResponseLogger(p)

	return &p, nil
}

// ExperiencesCursor is the resolver for the experiencesCursor field.
func (r *queryResolver) Experiences(ctx context.Context, first *int32, after *string) (*model.ExperienceConnection, error) {
	graphqlutils.RequestLogger(ctx, "Query Experience")

	var limit int32
	if first != nil {
		limit = *first
	} else {
		limit = 10 // default limit
	}

	var cursor string
	if after != nil {
		cursor = *after
	} else {
		cursor = ""
	}

	rows, err := config.DB.Query(ctx, `
        SELECT id, job_title, job_start_date, job_finish_date, job_description, created_at, created_by, updated_at, updated_by, is_active
        FROM mst_experience
        WHERE id > $1
        ORDER BY id ASC
        LIMIT $2
    `, cursor, limit)
	if err != nil {
		log.Println("Error fetching experiences: ", err)
		return nil, err
	}

	defer rows.Close()

	var experiences []*model.Experience
	var lastCursor string
	for rows.Next() {
		var exp model.Experience
		var jobStartDate, jobFinishDate, createdAt *time.Time

		if err := rows.Scan(
			&exp.ID, &exp.JobTitle, &jobStartDate, &jobFinishDate, &exp.JobDescription,
			&exp.CreatedAt, &exp.CreatedBy, &exp.UpdatedAt, &exp.UpdatedBy, &exp.IsActive,
		); err != nil {
			log.Println("Error scanning experience:", err)
			continue
		}

		// ✅ Convert time.Time to model.Time
		if ts := model.TimeFromPtr(createdAt); ts != nil {
			exp.CreatedAt = time.Time(*ts)
		}

		if ts := model.TimeFromPtr(jobStartDate); ts != nil {
			exp.JobStartDate = time.Time(*ts)
		}

		if ts := model.TimeFromPtr(jobFinishDate); ts != nil {
			exp.JobFinishDate = time.Time(*ts)
		}

		// p.JobFinishDate = model.TimeFromPtr(jobFinishDate)
		// p.UpdatedAt = model.TimeFromPtr(updatedAt)
		experiences = append(experiences, &exp)
		lastCursor = exp.ID
	}

	pageInfo := &model.PageInfo{
		EndCursor:   &lastCursor,
		HasNextPage: len(experiences) == int(limit),
	}

	edges := make([]*model.ExperienceEdge, len(experiences))
	for i, exp := range experiences {
		edges[i] = &model.ExperienceEdge{
			Cursor: exp.ID,
			Node:   exp,
		}
	}
	var response = &model.ExperienceConnection{
		Edges:    edges,
		PageInfo: pageInfo,
	}

	graphqlutils.ResponseLogger(response)

	return response, nil
}
