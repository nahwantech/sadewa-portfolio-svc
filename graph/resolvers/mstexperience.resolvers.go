package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"log"
	"sadewa-portfolio-svc/config"
	"sadewa-portfolio-svc/graph/model"
	"time"
	"sadewa-portfolio-svc/graphqlutils"
)

// CreateExperience is the resolver for the createExperience field.
func (r *mutationResolver) CreateExperience(ctx context.Context, input model.ExperienceInput) (*model.Experience, error) {
	panic(fmt.Errorf("not implemented: CreateExperience - createExperience"))
}

// UpdateExperience is the resolver for the updateExperience field.
func (r *mutationResolver) UpdateExperience(ctx context.Context, id string, input model.ExperienceInput) (*model.Experience, error) {
	panic(fmt.Errorf("not implemented: UpdateExperience - updateExperience"))
}

// DeleteExperience is the resolver for the deleteExperience field.
func (r *mutationResolver) DeleteExperience(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteExperience - deleteExperience"))
}

// Experiences is the resolver for the experiences field.
func (r *queryResolver) Experiences(ctx context.Context) ([]*model.Experience, error) {
	// print log 
	graphqlutils.RequestLogger(ctx, "Query Experience")
    
	rows, err := config.DB.Query(ctx, `
		SELECT id, job_title, job_start_date, job_finish_date, job_description, created_at, created_by, updated_at, updated_by, is_active
		FROM mst_experience
	`)

	if err != nil {
		log.Println("Error fetching experiences: ", err)
		return nil, err
	}

	defer rows.Close()

	var experiences []*model.Experience
	for rows.Next() {
		var p model.Experience
		var jobStartDate, jobFinishDate, createdAt, updatedAt *time.Time

		err := rows.Scan(
			&p.ID, &p.JobTitle, &jobStartDate, &jobFinishDate, &p.JobDescription,
			&createdAt, &p.CreatedBy, &updatedAt, &p.UpdatedBy, &p.IsActive,
		)

		if err != nil {
			log.Println("Error scanning experience:", err)
			continue
		}

		// ✅ Convert time.Time to model.Time
		if ts := model.TimeFromPtr(createdAt); ts != nil {
			p.CreatedAt = *ts
		}
	
		if ts := model.TimeFromPtr(jobStartDate); ts != nil {
			p.JobStartDate = *ts
		}

		if ts := model.TimeFromPtr(jobFinishDate); ts != nil {
			p.JobFinishDate = *ts
		}

		if updatedAt != nil {
			temp := model.ToModelTime(*updatedAt)
			p.UpdatedAt = &temp
		}

        // p.JobFinishDate = model.TimeFromPtr(jobFinishDate)
        // p.UpdatedAt = model.TimeFromPtr(updatedAt)

		experiences = append(experiences, &p)

	}


	graphqlutils.ResponseLogger(experiences)

	return experiences, nil
}

// Experience is the resolver for the experience field.
func (r *queryResolver) Experience(ctx context.Context, id string) (*model.Experience, error) {

	// print log 
	graphqlutils.RequestLogger(ctx, "Query Experience by id")
	
	var p model.Experience
	var jobStartDate, jobFinishDate, createdAt, updatedAt *time.Time
	err := config.DB.QueryRow(ctx, `
		SELECT id, job_title, job_start_date, job_finish_date, job_description, created_at, created_by, updated_at, updated_by, is_active
		FROM mst_experience
		WHERE id=$1
	`, id).Scan(
		&p.ID, &p.JobTitle, &jobStartDate, &jobFinishDate, &p.JobDescription,
			&createdAt, &p.CreatedBy, &updatedAt, &p.UpdatedBy, &p.IsActive,
	)

	// ✅ Convert time.Time to model.Time
	if ts := model.TimeFromPtr(createdAt); ts != nil {
		p.CreatedAt = *ts
	}

	if ts := model.TimeFromPtr(jobStartDate); ts != nil {
		p.JobStartDate = *ts
	}

	if ts := model.TimeFromPtr(jobFinishDate); ts != nil {
		p.JobFinishDate = *ts
	}

	if updatedAt != nil {
		temp := model.ToModelTime(*updatedAt)
		p.UpdatedAt = &temp
	}

	if err != nil {
		log.Println("Error fetching experience: ", err)
		return nil, err
	}

	graphqlutils.ResponseLogger(p)

	return &p, nil 
}
