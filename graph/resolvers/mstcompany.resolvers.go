package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"log"
	"sadewa-portfolio-svc/config"
	"sadewa-portfolio-svc/graph/model"
	"sadewa-portfolio-svc/graphqlutils"
	"time"
)

// Company is the resolver for the Company field.
func (r *queryResolver) Company(ctx context.Context, id string) (*model.Company, error) {
	panic(fmt.Errorf("not implemented: Company - Company"))
}

// Company is the resolver for the companys field.
func (r *queryResolver) Companys(ctx context.Context, first *int32, after *string) (*model.CompanyConnection, error) {
	graphqlutils.RequestLogger(ctx, "Query Company")

	var limit int32
	if first != nil {
		limit = *first
	} else {
		limit = 10 // default limit
	}

	var cursor string
	if after != nil {
		cursor = *after
	} else {
		cursor = ""
	}

	rows, err := config.DB.Query(ctx, `
        SELECT id, company_name, company_address, created_at, created_by, updated_at, updated_by, is_active
		FROM mst_company
        WHERE id > $1
        ORDER BY id ASC
        LIMIT $2
    `, cursor, limit)
	if err != nil {
		log.Println("Error fetching companys: ", err)
		return nil, err
	}

	defer rows.Close()

	var companys []*model.Company
	var lastCursor string
	for rows.Next() {
		var comp model.Company
		var createdAt *time.Time

		if err := rows.Scan(
			&comp.ID, &comp.CompanyName, &comp.CompanyAddress,
			&createdAt, &comp.CreatedBy, &comp.UpdatedAt, &comp.UpdatedBy, &comp.IsActive,
		); err != nil {
			log.Println("Error scanning Company:", err)
			continue
		}

		// âœ… Convert time.Time to model.Time
		if ts := model.TimeFromPtr(createdAt); ts != nil {
			comp.CreatedAt = time.Time(*ts)
		}

		companys = append(companys, &comp)
		lastCursor = comp.ID
	}

	pageInfo := &model.PageInfo{
		EndCursor:   &lastCursor,
		HasNextPage: len(companys) == int(limit),
	}

	edges := make([]*model.CompanyEdge, len(companys))
	for i, comp := range companys {
		edges[i] = &model.CompanyEdge{
			Cursor: comp.ID,
			Node:   comp,
		}
	}
	var response = &model.CompanyConnection{
		Edges:    edges,
		PageInfo: pageInfo,
	}

	graphqlutils.ResponseLogger(response)

	return response, nil
}
