package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"log"
	"sadewa-portfolio-svc/config"
	"sadewa-portfolio-svc/graph/model"
	"sadewa-portfolio-svc/graphqlutils"
	"time"
	"fmt"
)

// Education is the resolver for the Education field.
func (r *queryResolver) Education(ctx context.Context, id string) (*model.Education, error) {
	// print log

	graphqlutils.RequestLogger(ctx, "Query Education by id")

	var edc model.Education
	var createdAt *time.Time
	err := config.DB.QueryRow(ctx, `
		SELECT id, field_of_study, school, "degree", start_date, end_date, grade, description, activities_societies, skills, media, created_at, created_by, updated_at, updated_by, is_active
		FROM public.mst_education
		WHERE id=$1
	`, id).Scan(
		&edc.ID, &edc.FieldOfStudy, &edc.School, &edc.Degree, &edc.StartDate, &edc.EndDate,
		&edc.Grade, &edc.Description, &edc.ActivitiesSocietes, &edc.Skills, &edc.Media,
		&createdAt, &edc.CreatedBy, &edc.UpdatedAt, &edc.UpdatedBy, &edc.IsActive,
	)

	// ✅ Convert time.Time to model.Time
	if ts := model.TimeFromPtr(createdAt); ts != nil {
		edc.CreatedAt = time.Time(*ts)
	}

	if err != nil {
		log.Println("Error fetching Education: ", err)
		return nil, err
	}

	graphqlutils.ResponseLogger(edc)

	return &edc, nil
}

// EducationsCursor is the resolver for the EducationsCursor field.
func (r *queryResolver) Educations(ctx context.Context, first *int32, after *string, orderBy *model.EducationOrderByInput) (*model.EducationConnection, error) {
	graphqlutils.RequestLogger(ctx, "Query Education")

	var limit int32
	if first != nil {
		limit = *first
	} else {
		limit = 10 // default limit
	}

	// Initialize sorting parameters
	sortField := "end_date"
	sortDirection := "DESC"

	// Update sorting parameters based on orderBy input
	if orderBy != nil {
		if orderBy.EndDate != nil {
			sortField = "end_date"
			sortDirection = string(*orderBy.EndDate)
		}
		// Add additional fields as needed
	}

	var cursor string
	if after != nil {
		cursor = *after
	} else {
		cursor = ""
	}

	query := fmt.Sprintf(`
        SELECT id, field_of_study, school, "degree", start_date, end_date, grade, description, activities_societies, skills, media, created_at, created_by, updated_at, updated_by, is_active
		FROM public.mst_education
        ORDER BY %s %s
		OFFSET $1
        LIMIT $2
    `, sortField, sortDirection)

	rows, err := config.DB.Query(ctx, query, cursor, limit)
	if err != nil {
		log.Println("Error fetching Educations: ", err)
		return nil, err
	}

	defer rows.Close()

	var educations []*model.Education
	var lastCursor string
	for rows.Next() {
		var edc model.Education
		var createdAt *time.Time

		if err := rows.Scan(
			&edc.ID, &edc.FieldOfStudy, &edc.School, &edc.Degree, &edc.StartDate, &edc.EndDate,
			&edc.Grade, &edc.Description, &edc.ActivitiesSocietes, &edc.Skills, &edc.Media,
			&createdAt, &edc.CreatedBy, &edc.UpdatedAt, &edc.UpdatedBy, &edc.IsActive,
		); err != nil {
			log.Println("Error scanning Education:", err)
			continue
		}

		// ✅ Convert time.Time to model.Time
		if ts := model.TimeFromPtr(createdAt); ts != nil {
			edc.CreatedAt = time.Time(*ts)
		}

		educations = append(educations, &edc)
		lastCursor = edc.ID
	}

	pageInfo := &model.PageInfo{
		EndCursor:   &lastCursor,
		HasNextPage: len(educations) == int(limit),
	}

	edges := make([]*model.EducationEdge, len(educations))
	for i, edc := range educations {
		edges[i] = &model.EducationEdge{
			Cursor: edc.ID,
			Node:   edc,
		}
	}
	var response = &model.EducationConnection{
		Edges:    edges,
		PageInfo: pageInfo,
	}

	graphqlutils.ResponseLogger(response)

	return response, nil
}
