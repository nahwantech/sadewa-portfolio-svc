package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"log"
	"sadewa-portfolio-svc/config"
	"sadewa-portfolio-svc/graph/model"
	"sadewa-portfolio-svc/graphqlutils"
	"time"
)

// Create a new portfolio
func (r *mutationResolver) CreatePortfolio(ctx context.Context, input model.PortfolioInput) (*model.Portfolio, error) {
	var p model.Portfolio

	err := config.DB.QueryRow(ctx, `INSERT INTO mst_portfolio (title, description, backend_stack, frontend_stack, database_stack, deployment_stack, created_at, created_by, is_active)
	VALUES ($1, $2, $3, $4, $5, $6, NOW(), $7, $8) RETURNING id, title, description, backend_stack, frontend_stack, database_stack, deployment_stack, created_at, created_by, is_active`,
		input.Title, input.Description, input.BackendStack, input.FrontendStack, input.DatabaseStack, input.DeploymentStack, input.CreatedBy, input.IsActive).
		Scan(&p.ID, &p.Title, &p.Description, &p.BackendStack, &p.FrontendStack, &p.DatabaseStack, &p.DeploymentStack, &p.CreatedAt, &p.CreatedBy, &p.IsActive)

	if err != nil {
		log.Println("Error inserting portfolio:", err)
		return nil, err
	}
	return &p, nil
}

// UpdatePortfolio is the resolver for the updatePortfolio field.
func (r *mutationResolver) UpdatePortfolio(ctx context.Context, id string, input model.PortfolioInput) (*model.Portfolio, error) {
	panic(fmt.Errorf("not implemented: UpdatePortfolio - updatePortfolio"))
}

// DeletePortfolio is the resolver for the deletePortfolio field.
func (r *mutationResolver) DeletePortfolio(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeletePortfolio - deletePortfolio"))
}

// Fetch all portfolios
func (r *queryResolver) Portfolios(ctx context.Context, first *int32, after *string) (*model.PortfolioConnection, error) {
	var limit int32
	if first != nil {
		limit = *first
	} else {
		limit = 10 // default limit
	}

	var cursor string
	if after != nil {
		cursor = *after
	} else {
		cursor = ""
	}

	rows, err := config.DB.Query(ctx, `
		SELECT id, title, description, backend_stack, frontend_stack, database_stack, 
		       deployment_stack, created_at, created_by, updated_at, updated_by, is_active 
		FROM mst_portfolio
		WHERE id > $1
        ORDER BY id ASC
        LIMIT $2
	`, cursor, limit)
	if err != nil {
		log.Println("Error fetching portfolios:", err)
		return nil, err
	}
	defer rows.Close()

	var portfolios []*model.Portfolio
	var lastCursor string
	for rows.Next() {
		var p model.Portfolio
		var createdAt, updatedAt *time.Time

		err := rows.Scan(
			&p.ID, &p.Title, &p.Description, &p.BackendStack, &p.FrontendStack, &p.DatabaseStack,
			&p.DeploymentStack, &createdAt, &p.CreatedBy, &updatedAt, &p.UpdatedBy, &p.IsActive,
		)
		if err != nil {
			log.Println("Error scanning portfolio:", err)
			continue
		}

		// âœ… Convert time.Time to model.Time
		if ts := model.TimeFromPtr(createdAt); ts != nil {
			p.CreatedAt = time.Time(*ts)
		}

		portfolios = append(portfolios, &p)
		lastCursor = p.ID
	}

	pageInfo := &model.PageInfo{
		EndCursor:   &lastCursor,
		HasNextPage: len(portfolios) == int(limit),
	}

	edges := make([]*model.PortfolioEdge, len(portfolios))
	for i, p := range portfolios {
		edges[i] = &model.PortfolioEdge{
			Cursor: p.ID,
			Node:   p,
		}
	}

	var response = &model.PortfolioConnection{
		Edges:    edges,
		PageInfo: pageInfo,
	}

	graphqlutils.ResponseLogger(response)

	return response, nil
}

// Fetch a single portfolio
func (r *queryResolver) Portfolio(ctx context.Context, id string) (*model.Portfolio, error) {
	var p model.Portfolio
	err := config.DB.QueryRow(ctx, `SELECT id, title, description, backend_stack, frontend_stack, database_stack, deployment_stack, created_at, created_by, updated_at, updated_by, is_active FROM mst_portfolio WHERE id=$1`, id).
		Scan(&p.ID, &p.Title, &p.Description, &p.BackendStack, &p.FrontendStack, &p.DatabaseStack, &p.DeploymentStack, &p.CreatedAt, &p.CreatedBy, &p.UpdatedAt, &p.UpdatedBy, &p.IsActive)

	if err != nil {
		log.Println("Error fetching portfolio:", err)
		return nil, err
	}
	return &p, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
